import esbuild from "esbuild";
import console from "node:console";
import process from "node:process";
import builtins from "builtin-modules";
import dotenv from "dotenv";
import { z } from "zod";

// Load environment variables from .env (if present)
dotenv.config();

const banner = `/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/
`;

const externalDependencies = [
  "obsidian",
  "electron",
  "@codemirror/autocomplete",
  "@codemirror/collab",
  "@codemirror/commands",
  "@codemirror/language",
  "@codemirror/lint",
  "@codemirror/search",
  "@codemirror/state",
  "@codemirror/view",
  "@lezer/common",
  "@lezer/highlight",
  "@lezer/lr",
  ...builtins,
];

const baseOptions = {
  entryPoints: ["src/plugin/index.ts"],
  bundle: true,
  format: "cjs",
  target: "es2021",
  outfile: "main.js",
  banner: { js: banner },
  external: externalDependencies,
  logLevel: "info",
  treeShaking: true,
};

const environmentSchema = z.object({
  GOOGLE_CLIENT_ID: z.string().min(1, "GOOGLE_CLIENT_ID is required"),
});

const parsedEnvironment = (() => {
  const result = environmentSchema.safeParse(process.env);
  if (result.success) {
    return result.data;
  }
  const issues = result.error.issues
    .map((issue) => `${issue.path.join(".")}: ${issue.message}`)
    .join("; ");
  throw new Error(`Invalid build environment: ${issues}`);
})();

// Build-time environment variables injected into the bundle
const buildEnvironment = {
  GOOGLE_CLIENT_ID: parsedEnvironment.GOOGLE_CLIENT_ID,
};

const productionOptions = {
  ...baseOptions,
  sourcemap: false,
  minify: true,
  define: {
    "process.env": JSON.stringify(buildEnvironment),
  },
};

const developmentOptions = {
  ...baseOptions,
  sourcemap: "inline",
  minify: false,
  define: {
    "process.env": JSON.stringify(buildEnvironment),
  },
};

/**
 * Builds the plugin using esbuild with the provided options.
 *
 * @param {esbuild.BuildOptions} options - The build options for esbuild.
 * @returns {Promise<void>}
 */
const build = async (options) => {
  console.info("ðŸ”§ Building...");
  const context = await esbuild.context(options);
  try {
    await context.rebuild();
    console.info("âœ… Build succeeded.");
  } finally {
    await context.dispose();
  }
};

/**
 * Starts a file watcher that rebuilds the plugin on file changes.
 *
 * @param {esbuild.BuildOptions} options - The build options for esbuild.
 * @returns {Promise<void>}
 */
const watch = async (options) => {
  console.info("ðŸ‘€ Watching for changes...");
  const context = await esbuild.context(options);

  context.watch().catch((error) => {
    console.error("âŒ Watch failed:", error);
  });
};

/**
 * Parses the build mode from command-line arguments.
 *
 * @returns {"production" | "development" | "watch"} The current mode.
 */
const getMode = () => {
  const modeFlagIndex = process.argv.indexOf("--mode");
  return modeFlagIndex !== -1 && modeFlagIndex + 1 < process.argv.length
    ? process.argv[modeFlagIndex + 1]
    : "watch"; // default is "watch"
};

/**
 * Main entry point. Executes the appropriate build or watch based on the mode.
 *
 * @returns {Promise<void>}
 */
const run = async () => {
  const mode = getMode();
  console.info(`ðŸš€ Starting build script in mode: ${mode}`);

  switch (mode) {
    case "production": {
      await build(productionOptions);
      break;
    }
    case "development": {
      await build(developmentOptions);
      break;
    }
    default: {
      await watch(developmentOptions);
    }
  }
};

await run();
