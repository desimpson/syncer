import esbuild from "esbuild";
import console from "node:console";
import process from "node:process";
import builtins from "builtin-modules";

const banner = `/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/
`;

const externalDependencies = [
  "obsidian",
  "electron",
  "@codemirror/autocomplete",
  "@codemirror/collab",
  "@codemirror/commands",
  "@codemirror/language",
  "@codemirror/lint",
  "@codemirror/search",
  "@codemirror/state",
  "@codemirror/view",
  "@lezer/common",
  "@lezer/highlight",
  "@lezer/lr",
  ...builtins,
];

const baseOptions = {
  entryPoints: ["src/plugin/index.ts"],
  bundle: true,
  format: "cjs",
  target: "es2021",
  outfile: "main.js",
  banner: { js: banner },
  external: externalDependencies,
  logLevel: "info",
  treeShaking: true,
};

const productionOptions = {
  ...baseOptions,
  sourcemap: false,
  minify: true,
  define: {
    "process.env": JSON.stringify({
      // TODO: Create a production GCP project and set these values (securely - see below)
      GOOGLE_CLIENT_ID: "",
      GOOGLE_CLIENT_SECRET: "",
    }),
  },
};

const developmentOptions = {
  ...baseOptions,
  sourcemap: "inline",
  minify: false,
  define: {
    "process.env": JSON.stringify({
      /**
       * @note The Google API's authorisation code flow with PKCE seems to
       * require a client secret, even though it's not required in PKCE. So, we
       * have to bundle the secret (and client ID) with the plugin. Otherwise we
       * need to create a small backend server to handle the token exchange
       * securely. For this reason, the repo cannot be made public until the
       * backend server (most likely an AWS Lambda function) is implemented.
       *
       * @see https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow-with-pkce
       * @see https://discuss.google.dev/t/authorization-code-flow-without-client-secret/168113/2
       */
      GOOGLE_CLIENT_ID: "769446597482-0gmcfbcka0t6qftcanslrmtbfjg7kiqq.apps.googleusercontent.com",
      GOOGLE_CLIENT_SECRET: "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",
    }),
  },
};

/**
 * Builds the plugin using esbuild with the provided options.
 *
 * @param {esbuild.BuildOptions} options - The build options for esbuild.
 * @returns {Promise<void>}
 */
const build = async (options) => {
  console.info("ðŸ”§ Building...");
  const context = await esbuild.context(options);
  try {
    await context.rebuild();
    console.info("âœ… Build succeeded.");
  } finally {
    await context.dispose();
  }
};

/**
 * Starts a file watcher that rebuilds the plugin on file changes.
 *
 * @param {esbuild.BuildOptions} options - The build options for esbuild.
 * @returns {Promise<void>}
 */
const watch = async (options) => {
  console.info("ðŸ‘€ Watching for changes...");
  const context = await esbuild.context(options);

  context.watch().catch((error) => {
    console.error("âŒ Watch failed:", error);
  });
};

/**
 * Parses the build mode from command-line arguments.
 *
 * @returns {"production" | "development" | "watch"} The current mode.
 */
const getMode = () => {
  const modeFlagIndex = process.argv.indexOf("--mode");
  return modeFlagIndex !== -1 && modeFlagIndex + 1 < process.argv.length
    ? process.argv[modeFlagIndex + 1]
    : "watch"; // default is "watch"
};

/**
 * Main entry point. Executes the appropriate build or watch based on the mode.
 *
 * @returns {Promise<void>}
 */
const run = async () => {
  const mode = getMode();
  console.info(`ðŸš€ Starting build script in mode: ${mode}`);

  switch (mode) {
    case "production": {
      await build(productionOptions);
      break;
    }
    case "development": {
      await build(developmentOptions);
      break;
    }
    default: {
      await watch(developmentOptions);
    }
  }
};

await run();
